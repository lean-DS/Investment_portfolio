# -*- coding: utf-8 -*-
"""GCP.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mr7eYs1wORNswHObAutUZr2M6e9i2vf0
"""

# app.py
import os
import io
import time
from typing import List, Tuple, Dict, Optional

import streamlit as st
import pandas as pd
import numpy as np
import requests

# ---- our helper module (place file next to app.py) ----
from stockanalysis_scrapper import (
    fetch_all_symbols_from_sitemaps,
    fetch_uk_epics_from_lists,
)

# ------------------- Page Setup ------------------- #
st.set_page_config(page_title="Dynamic Portfolio Recommender", layout="centered")
st.title("Dynamic Portfolio Recommender")

# =========================================================
# Section 0: HTTP / data helpers (Stooq-based)
# =========================================================
SESSION = requests.Session()
SESSION.headers.update({
    "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 "
                  "(KHTML, like Gecko) Chrome/126.0 Safari/537.36",
    "Accept": "*/*",
    "Accept-Language": "en-US,en;q=0.9",
})
STQ_TIMEOUT = 10

def to_stooq_symbol(sym: str) -> Optional[str]:
    """Map a US or UK ticker to Stooq 's=' parameter. Returns None if we can't guess."""
    s = sym.strip().upper()
    if s in {"^GSPC", "^SPX"}:
        return "^spx"
    if s in {"^FTSE"}:
        return "^ftse"
    # try explicit LSE suffix
    if s.endswith(".L"):
        return f"{s[:-2].lower()}.uk"
    # EPICs like 'VOD' might be UK or US ADR; we'll first try US then '.uk' at callsites
    if s and any(c.isalpha() for c in s):
        return f"{s.lower()}.us"
    return None

def stooq_csv(symbol: str, interval="d") -> Optional[pd.DataFrame]:
    """Download OHLCV CSV from Stooq. Returns None on failure."""
    try:
        url = f"https://stooq.com/q/d/l/?s={symbol}&i={interval}"
        r = SESSION.get(url, timeout=STQ_TIMEOUT)
        if r.status_code != 200 or not r.text or r.text.lower().startswith("error"):
            return None
        df = pd.read_csv(io.StringIO(r.text))
        if df.empty or "Date" not in df.columns:
            return None
        df["Date"] = pd.to_datetime(df["Date"])
        df = df.sort_values("Date").reset_index(drop=True)
        return df
    except Exception:
        return None

def fetch_ohlcv_any(sym: str, min_rows: int = 100) -> Optional[pd.DataFrame]:
    """
    Try fetch from Stooq as US, then as UK (sym+'.L').
    Return OHLCV df or None.
    """
    # Try as-is (US guess)
    stq = to_stooq_symbol(sym)
    if stq:
        df = stooq_csv(stq)
        if df is not None and len(df) >= min_rows:
            return df
    # Try LSE form
    stq2 = to_stooq_symbol(sym + ".L")
    if stq2:
        df2 = stooq_csv(stq2)
        if df2 is not None and len(df2) >= min_rows:
            return df2
    return None

def stooq_has_history(sym: str, min_rows: int = 60) -> bool:
    df = fetch_ohlcv_any(sym, min_rows=min_rows)
    return df is not None

def load_universe_csv(filename: str) -> List[str]:
    """Load cached CSV with a 'Ticker' column."""
    try:
        if os.path.exists(filename):
            df = pd.read_csv(filename)
            col = next((c for c in df.columns if c.lower().startswith("ticker")), None)
            if col:
                return df[col].astype(str).str.upper().tolist()
    except Exception:
        pass
    return []

# =========================================================
# Section 1: UI — Investor Inputs
# =========================================================
st.header("Investor Profile")

age = st.number_input("Enter your Age", min_value=18, max_value=100, value=30)
goal = st.selectbox("What is your Investment Goal?", ["Capital Growth", "Dividend Income", "Balanced"])
horizon = st.slider("Investment Horizon (in years)", 1, 15, 3)
amount = st.number_input("Investment Amount (in £)", min_value=1000, step=1000, value=10000)

def recommend_risk_by_age(x: int) -> str:
    if x < 30: return "Aggressive"
    if x < 50: return "Moderate"
    return "Conservative"

recommended_risk = recommend_risk_by_age(age)
st.markdown(f"**System Recommendation:** Based on your age, you may consider a **{recommended_risk}** risk profile")

risk_profile = st.selectbox(
    "Select your Preferred Risk Profile",
    ["Conservative", "Moderate", "Aggressive"],
    index=["Conservative", "Moderate", "Aggressive"].index(recommended_risk)
)

def assign_beta_range(profile: str) -> Tuple[float, float]:
    if profile == "Conservative": return (0.5, 1.0)
    if profile == "Moderate":     return (1.1, 1.3)
    if profile == "Aggressive":   return (1.4, 2.2)
    return (1.0, 1.3)

min_beta, max_beta = assign_beta_range(risk_profile)
st.success(f"Your Portfolio Beta Range: {min_beta} – {max_beta}")

equity_percent = max(10, min(90, 100 - age))  # simple heuristic, lightly bounded
debt_percent = 100 - equity_percent
st.info(f"Suggested Split: **{equity_percent}% Equity**, **{debt_percent}% Debt/ETFs**")

# =========================================================
# Section 2: Universe builder (US + UK via StockAnalysis; validated with Stooq)
# =========================================================
st.header("Step 2: Global Universe (from StockAnalysis) + Goal/Horizon Scoring")

def get_equity_universe(max_us: int = 1500, max_uk: int = 1200) -> List[str]:
    """
    1) Live scrape US from StockAnalysis sitemaps & UK EPICs from LSE/AIM pages.
    2) If empty, load CSV caches.
    3) Validate each symbol with Stooq; keep only those with history.
    """
    # --- Try live US ---
    live_us = []
    try:
        sa = fetch_all_symbols_from_sitemaps(types=("stock",), max_per_type=max_us, max_sitemaps=10)
        live_us = sa.get("stock", [])
    except Exception:
        pass

    # --- Try live UK ---
    live_uk = []
    try:
        live_uk = fetch_uk_epics_from_lists()
    except Exception:
        pass

    # --- Fallback to cached CSVs if needed ---
    if not live_us:
        live_us = load_universe_csv("universe_us_stocks.csv")
    if not live_uk:
        live_uk = load_universe_csv("universe_uk_stocks.csv")

    # Merge + small dedupe
    merged = list(dict.fromkeys([*live_us[:max_us], *live_uk[:max_uk]]))

    # Validate with Stooq (only keep symbols that have history)
    valid: List[str] = []
    for s in merged:
        if stooq_has_history(s, min_rows=80):
            valid.append(s)
        # throttle a little to be polite
        if len(valid) % 50 == 0:
            time.sleep(0.2)
    return valid

# =========================================================
# Section 3: Features, scoring, and selection
# =========================================================
def total_return(close: pd.Series, days: int) -> float:
    if len(close) <= days: return np.nan
    return float(close.iloc[-1] / close.iloc[-1 - days] - 1.0)

def max_drawdown(close: pd.Series) -> float:
    roll_max = close.cummax()
    dd = (close / roll_max - 1.0)
    return float(dd.min())

def volatility(returns: pd.Series) -> float:
    return float(returns.std())

def normalize(s: pd.Series, invert=False) -> pd.Series:
    s = s.replace([np.inf, -np.inf], np.nan)
    if s.isna().all(): s = s.fillna(0.0)
    else:              s = s.fillna(s.median())
    lo, hi = s.min(), s.max()
    out = pd.Series(0.5, index=s.index) if hi == lo else (s - lo) / (hi - lo)
    return 1 - out if invert else out

def equity_weights(goal: str, horizon_years: int) -> Dict[str, float]:
    short = horizon_years < 3
    if goal == "Capital Growth":
        return {"mom3":0.40 if short else 0.25, "mom6":0.25, "mom12":0.15 if short else 0.30,
                "vol":0.10, "dd":0.10, "yield":0.00 if short else 0.10}
    if goal == "Dividend Income":
        return {"yield":0.55 if not short else 0.45, "vol":0.15, "dd":0.15,
                "mom3":0.05, "mom6":0.05, "mom12":0.05}
    # Balanced
    return {"mom3":0.20 if short else 0.15, "mom6":0.20, "mom12":0.20,
            "vol":0.15, "dd":0.15, "yield":0.10 if not short else 0.05}

def calc_beta(stock_close: pd.Series, bench_close: pd.Series) -> Optional[float]:
    sret = stock_close.pct_change().dropna()
    bret = bench_close.pct_change().dropna()
    aligned = pd.concat([sret, bret], axis=1, join="inner").dropna()
    if len(aligned) < 60: return None
    aligned.columns = ["stock", "bench"]
    var_b = aligned["bench"].var()
    if var_b == 0 or pd.isna(var_b): return None
    beta = aligned.cov().iloc[0, 1] / var_b
    return round(float(beta), 2)

def dynamic_universe_picker(min_beta: float, max_beta: float,
                            goal: str, horizon_years: int,
                            scan_cap: int = 400, want_equities: int = 50
                            ) -> pd.DataFrame:
    """
    1) Build validated universe (US+UK) from StockAnalysis (+ fallback CSVs).
    2) Fetch ACWI (as benchmark) from Stooq.
    3) Compute features + score and filter by beta window.
    """
    # 0) Benchmark (ACWI on Stooq is 'acwi.us')
    bench = stooq_csv("acwi.us")
    if bench is None or bench.empty:
        bench = stooq_csv("^spx")  # last resort
    if bench is None or bench.empty:
        raise RuntimeError("Could not fetch a benchmark (ACWI/^SPX).")

    bench_close = bench["Close"].dropna()

    # 1) Universe
    all_syms = get_equity_universe()
    if not all_syms:
        return pd.DataFrame(columns=["Ticker", "Beta", "Score"])

    # 2) Scan a subset for speed
    rows = []
    take = min(scan_cap, len(all_syms))
    for sym in all_syms[:take]:
        df = fetch_ohlcv_any(sym, min_rows=200)
        if df is None or "Close" not in df.columns:
            continue
        close = df["Close"].dropna()
        beta = calc_beta(close, bench_close)
        if beta is None or not (min_beta <= beta <= max_beta):
            continue

        # Features
        mom3  = total_return(close, 63)
        mom6  = total_return(close, 126)
        mom12 = total_return(close, 252)
        vol   = volatility(close.pct_change().dropna())
        mdd   = max_drawdown(close)

        # Dividend yield proxy: use Stooq 'Close' + try to fetch TTM dividend from Stooq is hard;
        # here we skip or set to 0; you can plug a fundamental API later.
        dy = 0.0

        avg_vol = 0.0
        if "Volume" in df.columns:
            avg_vol = float(df["Volume"].tail(60).mean())

        rows.append((sym, beta, avg_vol, mom3, mom6, mom12, vol, mdd, dy))

    if not rows:
        return pd.DataFrame(columns=["Ticker", "Beta", "Score"])

    eq = pd.DataFrame(rows, columns=["Ticker","Beta","Avg Volume (60d)","3M Return","6M Return","12M Return","Volatility","Max Drawdown","Dividend Yield"])

    # Score
    w = equity_weights(goal, horizon_years)
    score = (
        normalize(eq["3M Return"])   * w.get("mom3",0) +
        normalize(eq["6M Return"])   * w.get("mom6",0) +
        normalize(eq["12M Return"])  * w.get("mom12",0) +
        normalize(eq["Volatility"], invert=True) * w.get("vol",0) +
        normalize(eq["Max Drawdown"], invert=True) * w.get("dd",0) +
        normalize(eq["Dividend Yield"]) * w.get("yield",0)
    )
    eq["Score"] = score.fillna(0.0)
    eq = eq.sort_values(["Score","Avg Volume (60d)"], ascending=[False, False]).head(want_equities).reset_index(drop=True)
    return eq

# =========================================================
# Section 4: Debt ETFs (dynamic via Stooq)
# =========================================================
# A liquid, broad set of USD bond ETFs that Stooq typically supports
DEBT_ETF_CANDIDATES = [
    "TLT","HYG","LQD","AGG","IEF","BND","EMB","MUB","BNDX","SHY","IEI","TIP","VCIT","LQDH","BSV","GOVT",
    "IGSB","SPSB","SJNK","SHV","BIL","EDV","ZROZ","IEMB","IBTM.L","IGLT.L"  # a couple of LSE too
]

def rank_debt_etfs_by_liquidity(want: int = 30) -> pd.DataFrame:
    rows = []
    for t in DEBT_ETF_CANDIDATES:
        df = fetch_ohlcv_any(t, min_rows=60)
        if df is None or "Volume" not in df.columns:
            continue
        avgv = float(df["Volume"].tail(60).mean())
        rows.append((t, avgv))
    if not rows:
        return pd.DataFrame(columns=["Ticker","Avg Volume (60d)"])
    out = pd.DataFrame(rows, columns=["Ticker","Avg Volume (60d)"]).sort_values("Avg Volume (60d)", ascending=False)
    return out.head(want).reset_index(drop=True)

# =========================================================
# Section 5: Run
# =========================================================
if st.button("Build Dynamic Universe", type="primary"):
    try:
        with st.spinner("Building US+UK universe, fetching prices, and scoring..."):
            equities_df = dynamic_universe_picker(
                min_beta=min_beta, max_beta=max_beta,
                goal=goal, horizon_years=horizon,
                scan_cap=400, want_equities=50
            )

        if equities_df.empty:
            st.warning("No equities passed filters. Try another profile or widen the search later.")
        else:
            st.subheader("Candidate Equities")
            st.dataframe(equities_df, use_container_width=True)

        with st.spinner("Fetching bond ETFs and ranking by liquidity..."):
            debt_df = rank_debt_etfs_by_liquidity(want=30)

        st.subheader("Debt ETFs (ranked by liquidity)")
        if debt_df.empty:
            st.info("No bond ETFs found this run. Try again later.")
        else:
            st.dataframe(debt_df, use_container_width=True)

    except Exception as e:
        st.error(f"Universe build failed: {e}")
